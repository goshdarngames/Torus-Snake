/****************************************************************************
 * createVRScene.js
 *
 * Used to create an empty babylon scene with the default VR experience.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * createVRSceme ( babylon, engine )
     *
     * Returns a Babylon scene with the default VR experience.     
     */
    babylonProject.createVRScene = function ( babylon, engine )
    {
        let scene = new babylon.Scene ( engine );

        scene.createDefaultEnvironment ();
        
        let vrHelper = scene.createDefaultVRExperience ();

        let returnValue = 
        {
            scene    : scene,
            vrHelper : vrHelper
        };

        return returnValue;
    };
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * gameLoop.js
 *
 * This is the main game loop that is used to update objects and render
 * the scene.
 *
 * A finite state machine is used to switch between logical scenarios
 * such as the main menu or gameplay.
 *
 * The states are defined as functions that are to be executed each tick.
 *
 * The next function to be called to update the game's state is
 * stored as a function pointer in:
 *     
 *     babylonProject.nextUpdate;
 *
 * The game loop will call nextUpdate () and save its return as nextUpdate().
 *
 * The state functions are expected to wrap their data and execution in
 * an 'arrow operator' function pointer with any data they need and
 * return it so that calling nextUpdate () again will advance the state.
 *
 * The './pageLoaded.js' page loaded function sets the initial state to
 * 'babylonProject.StartState'.  This state can be found in the root
 * of the 'game_logic' directory and is a starting point for any game
 * using the base game as its template.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.nextUpdate
     *
     * This is expected to be a function pointer that can be called with
     * no paramters in order to advance the execution of the game by one
     * tick.
     *
     * The function should return a function pointer that can be called
     * with no paramters to execute the next tick.
     */
    babylonProject.nextUpdate = () => {};

    /**
     * babylonProject.gameLoop
     *
     * Calls babylonProject.nextUpdate () and saves its return in
     * babylonProject.nextUpdate.
     *
     * This should advance the game by one logic tick and save a function
     * pointer that can be called to execute the next tick.
     */
    babylonProject.gameLoop = function ()
    {
        //update state and store return value as next update
        babylonProject.nextUpdate = babylonProject.nextUpdate (); 
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * jQueryDomFunctions.js
 * 
 * Functions where the game interacts with the DOM are defined here.
 *
 * This function is outside the coverage of unit testing as it was 
 * awkward to mock jQuery and the DOM.
 *
 * Where possible it simply  passes DOM objects to a function within the
 * scope of tests.
 ***************************************************************************/

(function( babylonProject, $,  undefined )
{
    //Called when all HTML/DOM objects have been loaded.
    $(document).ready(function() 
    {
        babylonProject.pageLoaded ( document, BABYLON );
    });

    //Dynamically resizes the canvas as the browser window changes.
    // The babylon game engine is no longer available as a global var
    // if the resize function is needed in future it will have to be 
    // rewritten so that the engine instance is passed to it from the
    // pageloaded.js script
//    $(window).on("resize load", function()
//    {
//        if ( babylonProject.engine )
//        {
//            babylonProject.engine.resize();
//        }
//    });

} ( window.babylonProject = window.babylonProject || {},
    jQuery));

/****************************************************************************
 * pageLoaded.js
 *
 * The page loaded function is called by the jQueryDomFunctions.js 
 * module when the HTML Document is ready.
 *
 * This is the entry point into the game logic.  The game should be 
 * initialized and the first state of the finite state machine defined
 * in game_state/ should be loaded for the game loop to execute.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * pageLoaded ( documentRef, babylonRef )
     *
     * The first game logic function that is called when the
     * HTML page is ready.
     *
     * Sets the babylonProject.nextUpdate function pointer to be
     * babylonProject.startState
     *
     * Parameters:
     *  - documentRef: The HTML DOM object 'document'
     *  - babylonRef : A reference to the Babylon object
     */
    babylonProject.pageLoaded = function ( documentRef, babylonRef )
    {
        let canvas = documentRef.querySelector( "#renderCanvas" );

        let gameData = 
        {
            engine : babylonProject
                        .createBabylonEngine ( babylonRef, canvas )
        }

        //set the next update to be the startState function
        babylonProject.nextUpdate = () => 
                    babylonProject.startState( babylonRef, gameData );

        gameData.engine.runRenderLoop ( babylonProject.gameLoop );
    };

    /**
     * createBabylonEngine ( babylonRef, canvas )
     *
     * The call to the constructor of the Babylon engine has been 
     * encapsulated within this factory method to enable mocking
     * of the engine object during testing.
     */
    babylonProject.createBabylonEngine = function ( babylonRef, canvas )
    {
        //check if canvas is undefined as it would create a silent error
        //if the engine was initialized without a valid canvas

        if ( canvas == null )
        {
            throw "Canvas is undefined.";
        }

        return new babylonRef.Engine ( canvas, true );
    };
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * createSnakeState.js
 *
 * This state clears the board and creates a new snake.
 *
 * The snake parts are stored as list of objects in:
 *      
 *      gameData.snakeParts
 *
 * Each snake part is an object with an x and y value.  E.g:
 *
 *      { x : 1, y : 5 }
 *
 * The first value in the list represents the snake's head and the last
 * element is the tip of its tail.
 *
 * The y axis describes the long torus rings that  surround the player.  
 * The x-axis is along the smaller rings that form the circumference of the 
 * torus tube
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    babylonProject.createSnakeState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "GameData is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "Babylon is undefined." );
        }

        //create an empty list to hold the snake's body positions
        gameData.snakeParts = [];

        //create the snake as a line of 3 pieces along the y axis.
        // - Note:  The y axis describes the long torus rings that 
        //          surround the player.  The x-axis is the
        //          smaller rings that form the circumference of the 
        //          torus tube

        for ( let i=0; i<3; i++ )
        {
            gameData.snakeParts.push ( { x : 0, y : i } );
        }

        //return the snake move state as the next state
        return  () => babylonProject.snakeMoveState ( babylon, gameData );
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * snakeMoveState.js
 *
 * Checks if the snake has moved and updates the grid squares if so.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    babylonProject.snakeMoveState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "gameData is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "babylon is undefined." );
        }

        if ( gameData.snakeParts == undefined )
        {
            throw new Error ( "gameData.snakeParts is undefined." );
        }

        if ( gameData.snakeMoveInterval == undefined )
        {
            throw new Error ( "gameData.snakeMoveInterval is undefined." );
        }

        if ( gameData.snakeMoveTimer  == undefined )
        {
            throw new Error ( "gameData.snakeMoveTimer is undefined." );
        }

        //check if move timer has elapsed and move if so

        gameData.snakeMoveTimer -= gameData.engine.getDeltaTime ();

        if ( gameData.snakeMoveTimer <= 0 )
        {
            gameData.snakeMoveTimer = gameData.snakeMoveInterval;

            gameData.snakeParts = 
                window.babylonProject.moveSnake (
                        gameData.currentDir, 
                        gameData.snakeParts, 
                        gameData.wrapTorusCoord );

            gameData.applePos = 
            {
                x : gameData.applePos.x + gameData.currentDir.x,
                y : gameData.applePos.y + gameData.currentDir.y
            };

            gameData.applePos = 
                gameData.wrapTorusCoord ( gameData.applePos );

            window.babylonProject.updateTorusMeshes ( gameData );

        } 

        //render the scene and return next state

        gameData.scene.render ();

        return () => babylonProject.snakeMoveState ( babylon, gameData );
    }

    /**
     * babylonProject.moveSnake 
     *
     * Creates a copy of a snake with its parts moved in the desired
     * direction.
     *
     * Parameters:
     * - dir        : The { x, y } with the desired direction
     * - snakeParts : The list of { x, y } coordinates of the snake's body
     * - wrapFunc   : The function that should be used to wrap the 
     *                coordinates around the torus shape.  Usually expects
     *                the gameData.wrapTorusCoords defined in startState 
     */
    babylonProject.moveSnake = function ( dir, snakeParts, wrapFunc )
    {
        let newSnake = snakeParts.map ( function ( val, idx, arr )
        {
            let retVal = { x : 0, y : 0 };

            //snake head
            if ( idx == 0 )
            {
                return retVal;
            }

            //set tail elements to the sum of the next (reversed) element
            //and the movement direction
            
            else
            {
                retVal.x = arr [ idx - 1 ].x + dir.x;
                retVal.y = arr [ idx - 1 ].y + dir.y;

                return wrapFunc ( retVal );
            }

        });

        return newSnake;
    };

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * startState.js
 * 
 * The ./base_game/ functions define a gameLoop that expects a function
 * with no paramters each tick.
 *
 * On page load babylonProject.startState ( babylon, gameData ) is set to be
 * called.
 *
 * When called it is expected to update the game state and return a 
 * function pointer that can be called with no parameters on the next
 * update.
 *
 * By default the startState will expect the gameData to have a property
 * 'gameData.engine' that contains an instance of the BabylonJS engine 
 * created by the page loaded function.
 *
 * if gameData.scene has not beed defined the function will create it 
 * and the game objects needed.  Any extra data needed for the game will
 * be stored in gameData.
 *
 * The function will update the state and then use the javascript 
 * arrow notation to return a function pointer that can be called with no
 * paramters for the next update tick of the game loop.
 *      
 * See ./base_game/gameLoop.js for more information.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.startState ( babylon, gameData)
     *
     * Updates the game's state and returns a function that can be 
     * called with no paramters for the next update.
     */
    babylonProject.startState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "GameData is undefined." );
        }

        if ( gameData.engine == undefined )
        {
            throw new Error ( "Engine is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "Babylon is undefined." );
        }

        //private procedure used to initialize all the game objects
        initializeGameData ( babylon, gameData );

        return () => babylonProject.createSnakeState ( babylon, gameData );
    }; 

    /************************************************************************
     * PRIVATE FUNCTIONS
     ***********************************************************************/

    let initializeGameData = function ( babylon, gameData )
    {
        createScene ( babylon, gameData );

        createMaterials ( babylon, gameData );

        createTorus ( babylon, gameData );

        createTorusMeshes ( babylon, gameData ); 

        createTorusIndexFunctions ( gameData );

        //set apple pos to a value - this should be randomized later
        gameData.applePos = { x : 2, y : 1 };

        gameData.snakeMoveInterval = 750;

        gameData.snakeMoveTimer = gameData.snakeMoveInterval;

        gameData.dirLeft  = { x :  0, y :  1 };
        gameData.dirRight = { x :  0, y : -1 };
        gameData.dirUp    = { x : -1, y :  0 };
        gameData.dirDown  = { x :  1, y :  0 };

        gameData.currentDir = gameData.dirLeft;

    }

    let createScene = function ( babylon, gameData )
    {

        //create the VR scene using base_game/ createVRScene function
        let vrSceneData =
            babylonProject.createVRScene ( babylon, gameData.engine );
 
        gameData.scene = vrSceneData.scene;

        gameData.vrHelper = vrSceneData.vrHelper;

        //create light
        gameData.light = new babylon.DirectionalLight (
                "light", 
                new babylon.Vector3 ( 0, 0.5, 1.0 ), 
                gameData.scene  );
 
        gameData.light.position = new babylon.Vector3 ( 0, 5, 2 );

    }

    let createMaterials = function ( babylon, gameData )
    {

       gameData.torusMat = 
           new babylon.StandardMaterial ( "torusMat", gameData.scene );

       gameData.snakeMat = 
           new babylon.StandardMaterial ( "snakeMat", gameData.scene );

       gameData.snakeMat.diffuseColor =
           new babylon.Color3 ( 0, 255, 0 );

       gameData.appleMat = 
           new babylon.StandardMaterial ( "appleMat", gameData.scene );

       gameData.appleMat.diffuseColor =
           new babylon.Color3 ( 255, 0, 0 );

    }

    let createTorus = function ( babylon, gameData )
    {
        //Create torus
        torus_options = 
        {
            diameter : 3,
            thickness : 0.75,
            tessellation : 16 
        }
 
        gameData.torus = babylon.MeshBuilder.CreateTorus (
                "torus", torus_options, gameData.scene );
 
        gameData.torus.position = new babylon.Vector3 ( 0, 1, 0 );
 
        //set torus material and make wireframe
        gameData.torus.material = gameData.torusMat;
 
        gameData.torus.material.wireframe = true;
 
    }

    let createTorusMeshes = function ( babylon, gameData )
    {
        //create a mesh for every unique vertex of the torus
        //
        //There will be duplicated vertex positions for each row
        //and column of the grid.
        //
        //To avoid duplicate torus meshes the last element in each row
        //and the last column of the vertex data will be skipped
        //
        //A torus with tesselation of n will correspond to a snake
        //grid with n-1 rows and columns
        
        let torusVD = gameData.torus
            .getVerticesData ( babylon.VertexBuffer.PositionKind ) ;
 
        gameData.torusMeshes = [];
 
        //loop through vertex position buffer 3 spaces at a time 
        //in order to read position data as float3[]
        //
        //The loop termination condition stops before the last row
        //of data.

        let vertexGridElems = torusVD.length / 3;

        let vertexGridSize = Math.sqrt ( vertexGridElems );

        let snakeGridSize = vertexGridSize - 1;

        let snakeGridElems = snakeGridSize * snakeGridSize;

        //keep track of spawn count for assigning ID
        let spawnCount = 0;

        torusVD.forEach ( function ( value, idx, array )
        {
            //vector3s are stored as 3 list elements so only process
            //every third item
            
            if ( idx % 3 != 0 )
            {
                return;
            }

            //store the vector idx for readability

            let vectorIdx = idx/3;

            //skip the final row of vertex grid

            if ( vectorIdx >= vertexGridElems - vertexGridSize )
            {
                return;
            }

            //skip the final element of each row of the vertex grid

            if ( ( vectorIdx + 1 ) % vertexGridSize == 0 )
            {
                return;
            }
            
            //use string formatter to make unique name
            let meshName = `TorusMesh${ spawnCount++ }`; 
            
            let mesh = babylon.MeshBuilder.CreateSphere (
                    meshName,
                    { diameter : 0.1 },
                    gameData.scene );
 
            let vertexPos = babylon.Vector3.FromArray ( torusVD, idx );
 
            mesh.position = vertexPos.add (
                   gameData.torus.position,  );
 
            gameData.torusMeshes.push ( mesh );

        });
    }

    /**
     * This sub-routine stores function calls to the index mapping
     * functions so that they can be called elsewhere in the system
     * without having to pass things like the grid size or other
     * data that doesn't change throughout the game.
     */ 
    let createTorusIndexFunctions = function ( gameData )
    {
        let width = Math.sqrt ( gameData.torusMeshes.length );

        gameData.meshIdxToTorusCoord = 
            ( i ) => window.babylonProject.listIdxToCoord 
                         ( 
                            i, width, gameData.torusMeshes.length
                         );

        gameData.torusCoordToMeshIdx  = 
            ( coord ) => window.babylonProject.coordToListIdx  
                         ( 
                            coord, width, gameData.torusMeshes.length
                         );

        gameData.wrapTorusCoord  = 
            ( coord ) => window.babylonProject.wrapCoordinate  
                         ( 
                            coord, width, width
                         );

    }
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * torusCoordinates.js
 *
 * Provides a function that maps a set of 1 dimensional list indicies
 * to a two dimensional { x , y } coordinate tuple.
 *
 * The tests for the module have some examples of the functions with
 * various shapes of array
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    //This function allows negative numbers to be wrapped into positive
    //number.  Javascript's modulo returns a negative result for negative
    //values, which is not what is wanted to wrap coordinates.
    let wrap = ( x, n ) => ( x % n + n ) % n;

    babylonProject.listIdxToCoord = function ( idx, width, length )
    {
        if ( idx < 0 || idx == undefined )
        {
            throw ( "idx must be >= 0" );
        }

        if ( idx > length - 1)
        {
            throw ( "idx out of bounds of the list" );
        }

        if ( width < 1 || width == undefined )
        {
            throw ( "width must be >= 0" );
        }

        if ( length % width != 0 )
        {
            throw ( "width should divide length with no remainder." );
        }

        let coord = 
        { 
            x : idx % width,
            y : Math.floor ( idx/width )
        }

        return coord;
    }
    
    /**
     * coordToListIdx
     *
     * Maps a 2 dimensional coordinate to an index of a one dimensional
     * list.
     *
     * Coordinates outside the range of the 2D space will be wrapped
     * as though the space is a torus.
     *
     * Params:
     *  - coord  : The two dimensional { x, y } coordinate tuple
     *  - width  : The width of the 2D space
     *  - length : The number of elements in a 1D list containing all the 
     *             coordinates
     */
    babylonProject.coordToListIdx = function ( coord, width, length )
    {
        if ( width < 1 || width == undefined )
        {
            throw ( "width must be > 0" );
        }

        if ( length < 1 )
        {
            throw ( "list length must be > 0" );
        }

        if ( length % width != 0 )
        {
            throw ( "width should divide length with no remainder." );
        }

        let height = length / width;

        return width * wrap ( coord.y, height ) + wrap ( coord.x, width );
    };

    /**
     * wrapCoordinate
     *
     * Wraps the x and y of the coordinate parameter to  fit within
     * a torus shaped grid with the width and length provided.
     */
    babylonProject.wrapCoordinate = function ( coord, width, height )
    {
       let wrappedCoord = 
       {
           x : wrap ( coord.x, width ),
           y : wrap ( coord.y, height )
       };

       return wrappedCoord;
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * updateTorusMeshes.js
 *
 * Defines a function that updates a list of meshes in order to represent
 * the current state of the snake body.
 *
 * The headIndex parameter specifies which mesh should represent the head
 * of the snake.  The position of the other body parts will be calculated
 * relevant to this.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.updateTorusMeshes
     * 
     * Given a list of the meshes that appear at each vertex of the 
     * torus this function will toggle isVisible on each according
     * to the current position of the snake.
     */  
    babylonProject.updateTorusMeshes = function ( gameData )
    {

        if ( gameData == undefined )
        {
            throw ( "gameData parameter is undefined" );
        }
        
        if ( gameData.snakeParts == undefined )
        {
            throw (  "gameData.snakeParts should be a list of tuples" );
        }
        
        if ( gameData.torusMeshes == undefined )
        {
            throw ( "gameData.torusMeshes should be a list of "+
                    "meshes with length >= gameData.snakeParts" );
        }

        if ( gameData.torusMeshes.length < gameData.snakeParts.length )
        {
            throw ( "gameData.torusMeshes.length should be >= "+
                    "gameData.snakeParts.length" );
        }

        gridSize = Math.sqrt ( gameData.torusMeshes.length );

        if ( !Number.isInteger ( gridSize ) )
        {
            throw  ( "gameData.torusMeshes.length should be square number" );
        }

        let torusMeshes = gameData.torusMeshes;

        //set all torusMeshes to be invisble
        torusMeshes.forEach ( 
        function ( mesh, idx )
        {
            babylonProject.disableTorusMesh ( idx, gameData );
        });

        //set the snake torusMeshes to be visible
        gameData.snakeParts.forEach (
        function ( s )
        {
            let meshIdx = gameData.torusCoordToMeshIdx ( s );

            babylonProject.enableTorusMesh ( 
                    meshIdx, gameData.snakeMat, gameData );
        });

        //set the apple mesh to be visible

        let appleIdx = gameData.torusCoordToMeshIdx ( gameData.applePos );

        babylonProject.enableTorusMesh ( 
            appleIdx, gameData.appleMat, gameData );
    }

    babylonProject.disableTorusMesh = function ( meshIdx, gameData )
    {
        if ( gameData == undefined )
        {
            throw ( "gameData is undefined" );
        }

        if ( gameData.torusMeshes == undefined )
        {
            throw ( "gameData.torusMeshes is undefined" );
        }

        if ( meshIdx < 0 || meshIdx > gameData.torusMeshes.length )
        {
            throw ( "meshIdx outside torus mesh list range" );
        }

        gameData.torusMeshes [ meshIdx ].isVisible = false;

    }

    babylonProject.enableTorusMesh = function ( meshIdx, material, gameData )
    {
        if ( gameData == undefined )
        {
            throw ( "gameData is undefined" );
        }

        if ( gameData.torusMeshes == undefined )
        {
            throw ( "gameData.torusMeshes is undefined" );
        }

        if ( meshIdx < 0 || meshIdx > gameData.torusMeshes.length )
        {
            throw ( "meshIdx outside torus mesh list range" );
        }

        if ( material == undefined )
        {
            throw ( "material undefined" );
        }

        gameData.torusMeshes [ meshIdx ].isVisible = true;

        gameData.torusMeshes [ meshIdx ].material = material;
    }

} ( window.babylonProject = window.babylonProject || {} ));

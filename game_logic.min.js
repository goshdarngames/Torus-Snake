/****************************************************************************
 * createVRScene.js
 *
 * Used to create an empty babylon scene with the default VR experience.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * createVRSceme ( babylon, engine )
     *
     * Returns a Babylon scene with the default VR experience.     
     */
    babylonProject.createVRScene = function ( babylon, engine )
    {
        let scene = new babylon.Scene ( engine );

        scene.createDefaultEnvironment ();
        
        scene.createDefaultVRExperience ();

        return scene;
    };
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * gameLoop.js
 *
 * This is the main game loop that is used to update objects and render
 * the scene.
 *
 * A finite state machine is used to switch between logical scenarios
 * such as the main menu or gameplay.
 *
 * The states are defined as functions that are to be executed each tick.
 *
 * The next function to be called to update the game's state is
 * stored as a function pointer in:
 *     
 *     babylonProject.nextUpdate;
 *
 * The game loop will call nextUpdate () and save its return as nextUpdate().
 *
 * The state functions are expected to wrap their data and execution in
 * an 'arrow operator' function pointer with any data they need and
 * return it so that calling nextUpdate () again will advance the state.
 *
 * The './pageLoaded.js' page loaded function sets the initial state to
 * 'babylonProject.StartState'.  This state can be found in the root
 * of the 'game_logic' directory and is a starting point for any game
 * using the base game as its template.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.nextUpdate
     *
     * This is expected to be a function pointer that can be called with
     * no paramters in order to advance the execution of the game by one
     * tick.
     *
     * The function should return a function pointer that can be called
     * with no paramters to execute the next tick.
     */
    babylonProject.nextUpdate = () => {};

    /**
     * babylonProject.gameLoop
     *
     * Calls babylonProject.nextUpdate () and saves its return in
     * babylonProject.nextUpdate.
     *
     * This should advance the game by one logic tick and save a function
     * pointer that can be called to execute the next tick.
     */
    babylonProject.gameLoop = function ()
    {
        //update state and store return value as next update
        babylonProject.nextUpdate = babylonProject.nextUpdate (); 
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * jQueryDomFunctions.js
 * 
 * Functions where the game interacts with the DOM are defined here.
 *
 * This function is outside the coverage of unit testing as it was 
 * awkward to mock jQuery and the DOM.
 *
 * Where possible it simply  passes DOM objects to a function within the
 * scope of tests.
 ***************************************************************************/

(function( babylonProject, $,  undefined )
{
    //Called when all HTML/DOM objects have been loaded.
    $(document).ready(function() 
    {
        babylonProject.pageLoaded ( document, BABYLON );
    });

    //Dynamically resizes the canvas as the browser window changes.
    // The babylon game engine is no longer available as a global var
    // if the resize function is needed in future it will have to be 
    // rewritten so that the engine instance is passed to it from the
    // pageloaded.js script
//    $(window).on("resize load", function()
//    {
//        if ( babylonProject.engine )
//        {
//            babylonProject.engine.resize();
//        }
//    });

} ( window.babylonProject = window.babylonProject || {},
    jQuery));

/****************************************************************************
 * pageLoaded.js
 *
 * The page loaded function is called by the jQueryDomFunctions.js 
 * module when the HTML Document is ready.
 *
 * This is the entry point into the game logic.  The game should be 
 * initialized and the first state of the finite state machine defined
 * in game_state/ should be loaded for the game loop to execute.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * pageLoaded ( documentRef, babylonRef )
     *
     * The first game logic function that is called when the
     * HTML page is ready.
     *
     * Sets the babylonProject.nextUpdate function pointer to be
     * babylonProject.startState
     *
     * Parameters:
     *  - documentRef: The HTML DOM object 'document'
     *  - babylonRef : A reference to the Babylon object
     */
    babylonProject.pageLoaded = function ( documentRef, babylonRef )
    {
        let canvas = documentRef.querySelector( "#renderCanvas" );

        let gameData = 
        {
            engine : babylonProject
                        .createBabylonEngine ( babylonRef, canvas )
        }

        //set the next update to be the startState function
        babylonProject.nextUpdate = () => 
                    babylonProject.startState( babylonRef, gameData );

        gameData.engine.runRenderLoop ( babylonProject.gameLoop );
    };

    /**
     * createBabylonEngine ( babylonRef, canvas )
     *
     * The call to the constructor of the Babylon engine has been 
     * encapsulated within this factory method to enable mocking
     * of the engine object during testing.
     */
    babylonProject.createBabylonEngine = function ( babylonRef, canvas )
    {
        //check if canvas is undefined as it would create a silent error
        //if the engine was initialized without a valid canvas

        if ( canvas == null )
        {
            throw "Canvas is undefined.";
        }

        return new babylonRef.Engine ( canvas, true );
    };
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * createSnakeState.js
 *
 * This state clears the board and creates a new snake.
 *
 * The snake parts are stored as list of objects in:
 *      
 *      gameData.snakeParts
 *
 * Each snake part is an object with an x and y value.  E.g:
 *
 *      { x : 1, y : 5 }
 *
 * The first value in the list represents the snake's head and the last
 * element is the tip of its tail.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    babylonProject.createSnakeState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "GameData is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "Babylon is undefined." );
        }

        //create an empty list to hold the snake's body positions
        gameData.snakeParts = [];

        //create the three initial pieces in a horizontal line
        for ( let i=0; i<3; i++ )
        {
            gameData.snakeParts.push ( { x : i, y : 0 } );
        }

        //return the snake move state as the next state
        return  () => babylonProject.snakeMoveState ( babylon, gameData );
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * snakeMoveState.js
 *
 * Checks if the snake has moved and updates the grid squares if so.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    babylonProject.snakeMoveState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "gameData is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "babylon is undefined." );
        }

        if ( gameData.snakeParts == undefined )
        {
            throw new Error ( "gameData.snakeParts is undefined." );
        }
    }

} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * startState.js
 * 
 * The ./base_game/ functions define a gameLoop that expects a function
 * with no paramters each tick.
 *
 * On page load babylonProject.startState ( babylon, gameData ) is set to be
 * called.
 *
 * When called it is expected to update the game state and return a 
 * function pointer that can be called with no parameters on the next
 * update.
 *
 * By default the startState will expect the gameData to have a property
 * 'gameData.engine' that contains an instance of the BabylonJS engine 
 * created by the page loaded function.
 *
 * if gameData.scene has not beed defined the function will create it 
 * and the game objects needed.  Any extra data needed for the game will
 * be stored in gameData.
 *
 * The function will update the state and then use the javascript 
 * arrow notation to return a function pointer that can be called with no
 * paramters for the next update tick of the game loop.
 *      
 * See ./base_game/gameLoop.js for more information.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    /**
     * babylonProject.startState ( babylon, gameData)
     *
     * Updates the game's state and returns a function that can be 
     * called with no paramters for the next update.
     */
    babylonProject.startState = function ( babylon, gameData )
    {
        if ( gameData == undefined )
        {
            throw new Error ( "GameData is undefined." );
        }

        if ( gameData.engine == undefined )
        {
            throw new Error ( "Engine is undefined." );
        }

        if ( babylon == undefined )
        {
            throw new Error ( "Babylon is undefined." );
        }

        if ( gameData.scene == undefined )
        {
            //private procedure used to initialize all the game objects
            initializeGameData ( babylon, gameData );
        }

        gameData.scene.render ();

        return () => babylonProject.createSnakeState ( babylon, gameData );
    }; 

    /************************************************************************
     * PRIVATE FUNCTIONS
     ***********************************************************************/

    let initializeGameData = function ( babylon, gameData )
    {
       //create the VR scene using base_game/ createVRScene function
       gameData.scene =
           babylonProject.createVRScene ( babylon, gameData.engine );

       //create light
       gameData.light = new babylon.DirectionalLight (
               "light", 
               new babylon.Vector3 ( 0, 0.5, 1.0 ), 
               gameData.scene  );

       gameData.light.position = new babylon.Vector3 ( 0, 5, 2 );

       //Create torus
       torus_options = 
       {
           diameter : 3,
           thickness : 0.75,
           tessellation : 16 
       }

       gameData.torus = babylon.MeshBuilder.CreateTorus (
               "torus", torus_options, gameData.scene );

       gameData.torus.position = new babylon.Vector3 ( 0, 1, 0 );

       //set torus material and make wireframe
       gameData.torus.material =
           new babylon.StandardMaterial ( "torusMat", gameData.scene );

       gameData.torus.material.wireframe = true;

       //create a cube for every vertex of the torus
       
       let torusVD = gameData.torus
           .getVerticesData ( babylon.VertexBuffer.PositionKind ) ;

       gameData.torusCubes = [];

       //loop through vertex position buffer 3 spaces at a time 
       //in order to read position data as float3[]

       for ( let i = 0; i < torusVD.length; i += 3 )
       {
           let cube = babylon.MeshBuilder.CreateBox (
                   `TorusCube${ i/3 }`,
                   { size : 0.1 },
                   gameData.scene );

           let vertexPos = babylon.Vector3.FromArray ( torusVD, i );

           cube.position = vertexPos.add (
                  gameData.torus.position,  );

//           cube.position = babylon.Vector3.TransformCoordinates ( 
//                  vertexPos, gameData.torus.getWorldMatrix () ); 

           gameData.torusCubes.push ( cube );
       }
       

    }
} ( window.babylonProject = window.babylonProject || {} ));

/****************************************************************************
 * updateTorusMeshes.js
 *
 * Defines a function that updates a list of meshes in order to represent
 * the current state of the snake body.
 *
 * The headIndex parameter specifies which mesh should represent the head
 * of the snake.  The position of the other body parts will be calculated
 * relevant to this.
 ***************************************************************************/

( function ( babylonProject, undefined )
{
    babylonProject.updateTorusMeshes =  
        function 
        (
             meshes, 
             snakeParts, 
             headIndex 
        )
    {

        if ( snakeParts == undefined )
        {
            throw (  "snakeParts should be a list of tuples" );
        }
        
        if ( meshes == undefined )
        {
            throw ( "meshes paramter should be a list of meshes with " +
                    "length >= snakeParts" );
        }

        if ( meshes.length < snakeParts.length )
        {
            throw ( "meshes.length should be >= snakeParts.length" );
        }
    }

} ( window.babylonProject = window.babylonProject || {} ));
